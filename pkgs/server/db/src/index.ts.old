import type { ParsedConfig } from 'boot/dev/config-parse'
import { fork } from 'child_process'
import type dbs_type from 'dbs'
import { dirname, join } from 'path'
import { createDBSProxy, onSend } from 'proxy'
import { waitUntil } from 'server-utility'
import { IServerInit } from '../../web/src'
import { IDBMsg, randomDigits } from '../../web/src/routes/serve-db'

const cwd = join(dirname(__filename), '..')
export const dbs = {} as typeof dbs_type

const define = (name: string, value: any) => {
  const g = global as any
  if (!g[name]) {
    g[name] = value
  }
}

const sendQueryToParentCluster = (args: Partial<IDBMsg>, workerId: string) => {
  const g = global as any
  let queue = g.dbQueryQueue
  if (!g.dbQueryQueue) {
    g.dbQueryQueue = {}
    queue = g.dbQueryQueue
  }

  return new Promise((resolve) => {
    let mid = `${workerId}|(new Date().getTime())|${randomDigits(5)}`
    while (queue[mid]) {
      mid = `${workerId}|(new Date().getTime())|${randomDigits(5)}`
    }

    if (process.send) {
      process.send({
        action: 'db.query',
        dbQuery: { ...args, mid },
      } as IServerInit)
    }

    queue[mid] = resolve
  })
}

export default {
  clusterProxy: async (config: ParsedConfig, workerId: string) => {
    return createDBSProxy(config, (args) => {
      return sendQueryToParentCluster(args, workerId)
    })
  },
  workerClusterOnMessage: () => {},
  parentClusterOnMessage: (
    data: IServerInit,
    dbs: ReturnType<typeof createDBSProxy>
  ) => {
    if (data.action === 'db.query' && data.dbQuery) {
      const { db, action, mid, params, table } = data.dbQuery
      
    }
  },
  forkProxy: (config: ParsedConfig): ReturnType<typeof createDBSProxy> => {
    return createDBSProxy(config, ({ db, table, action, params }) => {
      return new Promise<any>(async (resolve) => {
        if (db) {
          const fk = forks[db]
          if (fk) {
            let id = ''
            new Date().getTime() + '|' + randomDigits(5)
            while (dbQueue[id]) {
              id = new Date().getTime() + '|' + randomDigits(5)
            }
            dbQueue[id] = resolve
            if (!fk.ready) {
              await waitUntil(() => fk.ready)
            }
            fk.send({ id, table, action, params })
          }
        }
      })
    })
  },
  startFork: async (config: ParsedConfig) => {
    define('dbQueue', {})
    define('forks', {})
    define('config', config)

    const forkDb = [] as Promise<void>[]
    for (let name of Object.keys(config.dbs)) {
      forkDb.push(
        new Promise(async (resolveFork) => {
          const setupFork = () => {
            forks[name] = fork(join(cwd, 'pkgs', 'dbs', name, 'db.js')) as any
            forks[name].once('spawn', () => {
              forks[name].ready = true
            })
            forks[name].on(
              'message',
              (data: { id: string; value: any; event?: 'ready' }) => {
                if (data.event === 'ready') {
                  resolveFork()
                } else {
                  if (data.id) {
                    const resolveDbQueue = dbQueue[data.id] as any
                    if (resolveDbQueue) {
                      resolveDbQueue(data.value)
                      delete dbQueue[data.id]
                    }
                  }
                }
              }
            )
            forks[name].stdout?.pipe(process.stdout)
            forks[name].stderr?.pipe(process.stderr)
            forks[name].once('disconnect', () => {
              forks[name].ready = false
              setupFork()
            })
          }
          setupFork()
        })
      )
    }
    await Promise.all(forkDb)
  },
  stopFork: async () => {
    for (let f of Object.values(forks)) {
      f.kill()
    }
  },
}
